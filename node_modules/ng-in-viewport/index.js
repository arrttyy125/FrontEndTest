import { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, Output } from '@angular/core';

let InViewportConfigDirection = {};
InViewportConfigDirection.Both = 0;
InViewportConfigDirection.Vertical = 1;
InViewportConfigDirection.Horizontal = 2;
InViewportConfigDirection[InViewportConfigDirection.Both] = "Both";
InViewportConfigDirection[InViewportConfigDirection.Vertical] = "Vertical";
InViewportConfigDirection[InViewportConfigDirection.Horizontal] = "Horizontal";
class InViewportConfig {
    /**
     * @param {?=} options
     */
    constructor(options) {
        this.rootElement = (options && options.rootElement)
            ? options.rootElement
            : void 0;
        this.partial = (options && 'partial' in options)
            ? options.partial
            : true;
        this.direction = (options && 'direction' in options)
            ? options.direction
            : InViewportConfigDirection.Both;
    }
    /**
     * @return {?}
     */
    get rootElement() {
        return this._rootElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rootElement(value) {
        this._rootElement = value;
    }
    /**
     * @return {?}
     */
    get partial() {
        return this._partial;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set partial(value) {
        this._partial = !!(value);
    }
    /**
     * @return {?}
     */
    get direction() {
        return this._direction;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set direction(value) {
        this._direction = value;
    }
}

class InViewportService {
    constructor() {
        this.registry = [];
        this.trigger$ = new EventEmitter();
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    onChanges(entries) {
        this.trigger$.emit(entries);
    }
    /**
     * @param {?} rootElement
     * @return {?}
     */
    findRegistryEntry(rootElement) {
        return this.registry.find((item) => item.rootElement === this.getRootElement(rootElement));
    }
    /**
     * @param {?} target
     * @param {?=} rootElement
     * @return {?}
     */
    addTarget(target, rootElement) {
        let /** @type {?} */ registryEntry = this.findRegistryEntry(rootElement);
        if (!registryEntry) {
            const /** @type {?} */ registryEntryObserverOptions = {
                root: this.getRootElement(rootElement),
                threshold: Array(101).fill(void 0).map((item, i) => (i / 100))
            };
            registryEntry = {
                targets: [target],
                rootElement: this.getRootElement(rootElement),
                observer: new IntersectionObserver((entries) => this.onChanges(entries), registryEntryObserverOptions)
            };
            registryEntry.observer.observe(target);
            this.registry.push(registryEntry);
        }
        else if (registryEntry.targets.indexOf(target) < 0) {
            registryEntry.targets.push(target);
            registryEntry.observer.observe(target);
        }
    }
    /**
     * @param {?} target
     * @param {?=} rootElement
     * @return {?}
     */
    removeTarget(target, rootElement) {
        const /** @type {?} */ registryEntry = this.findRegistryEntry(rootElement);
        const /** @type {?} */ registryEntryIdx = this.registry.indexOf(registryEntry);
        if (registryEntry) {
            const /** @type {?} */ targetIdx = registryEntry.targets.indexOf(target);
            if (targetIdx >= 0) {
                registryEntry.observer.unobserve(target);
                registryEntry.targets.splice(targetIdx, 1);
            }
            if (registryEntry.targets.length === 0) {
                registryEntry.observer.disconnect();
                this.registry.splice(registryEntryIdx, 1);
            }
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getRootElement(element) {
        return (element && element.nodeType === 1) ? element : null;
    }
}
InViewportService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
InViewportService.ctorParameters = () => [];

class InViewportDirective {
    /**
     * @param {?} elementRef
     * @param {?} inViewportService
     */
    constructor(elementRef, inViewportService) {
        this.elementRef = elementRef;
        this.inViewportService = inViewportService;
        this.config = new InViewportConfig();
        this.action$ = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set updateConfig(value) {
        if (value && Object.prototype.toString.call(value) === '[object Object]') {
            if (value.rootElement instanceof Element) {
                this.config.rootElement = value.rootElement;
            }
            if ('partial' in value) {
                this.config.partial = value.partial;
            }
            if ('direction' in value) {
                this.config.rootElement = value.direction;
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.inViewportService.trigger$.subscribe((entries) => this.check(entries));
        this.inViewportService.addTarget(this.elementRef.nativeElement, this.config.rootElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.inViewportService.removeTarget(this.elementRef.nativeElement);
    }
    /**
     * @param {?} entries
     * @return {?}
     */
    check(entries) {
        const /** @type {?} */ entry = entries.find((item) => item.target === this.elementRef.nativeElement);
        if (entry) {
            const /** @type {?} */ value = this.config.partial ? (entry.intersectionRatio > 0) : (entry.intersectionRatio === 1);
            this.action$.emit({
                target: entry.target,
                value
            });
        }
    }
}
InViewportDirective.decorators = [
    { type: Directive, args: [{
                selector: '[in-viewport], [inViewport]'
            },] },
];
/**
 * @nocollapse
 */
InViewportDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: InViewportService, },
];
InViewportDirective.propDecorators = {
    'action$': [{ type: Output, args: ['inViewportAction',] },],
    'updateConfig': [{ type: Input, args: ['inViewportOptions',] },],
};

class InViewportModule {
    /**
     * @param {?} inViewportService
     */
    constructor(inViewportService) {
        this.inViewportService = inViewportService;
    }
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: InViewportModule,
            providers: [
                InViewportService
            ]
        };
    }
}
InViewportModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    InViewportDirective
                ],
                exports: [
                    InViewportDirective
                ]
            },] },
];
/**
 * @nocollapse
 */
InViewportModule.ctorParameters = () => [
    { type: InViewportService, },
];

/**
 * Generated bundle index. Do not edit.
 */

export { InViewportModule, InViewportService, InViewportConfig, InViewportConfigDirection, InViewportDirective };
